<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Guide: Singleton vs Static Logger in Java</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:#f7f8fa; color:#111827; padding:24px; }
    .container { max-width:900px; margin:0 auto; background:#fff; border-radius:12px; box-shadow:0 6px 20px rgba(17,24,39,0.08); padding:20px; position:relative; }
    h1 { font-size:24px; margin-bottom:12px; }
    h2 { font-size:18px; margin-top:20px; margin-bottom:10px; }
    p { margin: 8px 0; }
    ul { margin: 8px 0 16px 20px; }
    pre { background: #0b1220; color:#e6eef8; padding:12px; border-radius:8px; overflow:auto; font-size:13px; }
    code { font-family: SFMono-Regular, Menlo, Monaco, 'Courier New', monospace; }
    .footer { margin-top:24px; color:#6b7280; font-size:13px; }
    .download { position:absolute; top:20px; right:20px; background:#2563eb; color:#fff; padding:8px 14px; border-radius:8px; text-decoration:none; font-size:14px; box-shadow:0 2px 6px rgba(0,0,0,0.15); }
    .download:hover { background:#1e4ed8; }
  </style>
</head>
<body>
  <div class="container">
    <a href="data:text/html;charset=utf-8,<!doctype html>%0A<html lang='en'>%0A<head><meta charset='utf-8' /><title>Guide: Singleton vs Static Logger in Java</title></head><body>%0A" download="singleton_vs_static_logger.html" class="download">Download</a>
    
    <h1>Singleton vs Static Logger in Java</h1>
    <p>This guide explains why the Singleton pattern is often recommended for logging in Java, instead of simply using static methods. While both approaches can achieve similar results for basic logging, the Singleton pattern provides important advantages in flexibility, testability, and maintainability.</p>

    <h2>Why Not Just Static Methods?</h2>
    <p>Static methods seem convenient for logging, but they have several limitations:</p>
    <ul>
      <li><strong>No flexibility:</strong> Static methods are tied to the class; behavior changes require code modification.</li>
      <li><strong>Global state:</strong> Configuration must be stored in static variables, which is harder to manage and test.</li>
      <li><strong>No polymorphism:</strong> You canâ€™t swap out implementations at runtime.</li>
      <li><strong>Difficult to test:</strong> Mocking or stubbing static methods requires special frameworks.</li>
    </ul>

    <h2>Benefits of Singleton Logger</h2>
    <ul>
      <li><strong>Configurable:</strong> Store log levels, formats, or destinations as instance fields.</li>
      <li><strong>Injectable:</strong> Pass the singleton into other classes for better dependency management.</li>
      <li><strong>Polymorphic:</strong> Replace with different implementations (console, file, remote) without touching consumers.</li>
      <li><strong>Testable:</strong> Use mocks or stubs during testing.</li>
    </ul>

    <h2>Static Logger Example</h2>
    <pre><code>// Static logger utility
public class StaticLogger {
    private static String logLevel = "INFO";

    public static void setLogLevel(String level) {
        logLevel = level;
    }

    public static void log(String message) {
        System.out.println("[" + logLevel + "] " + message);
    }
}

// Usage
public class App {
    public static void main(String[] args) {
        StaticLogger.log("Application started");
        StaticLogger.setLogLevel("DEBUG");
        StaticLogger.log("Debugging info");
    }
}
</code></pre>
    <p><strong>Pros:</strong> Simple, no instance needed. <br>
       <strong>Cons:</strong> Hard to replace, test, or extend.</p>

    <h2>Singleton Logger Example</h2>
    <pre><code>// Singleton logger
public class SingletonLogger {
    private static SingletonLogger instance;
    private String logLevel = "INFO";

    private SingletonLogger() {}  // private constructor

    public static synchronized SingletonLogger getInstance() {
        if (instance == null) {
            instance = new SingletonLogger();
        }
        return instance;
    }

    public void setLogLevel(String level) {
        this.logLevel = level;
    }

    public void log(String message) {
        System.out.println("[" + logLevel + "] " + message);
    }
}

// Usage
public class App {
    public static void main(String[] args) {
        SingletonLogger logger = SingletonLogger.getInstance();
        logger.log("Application started");
        logger.setLogLevel("DEBUG");
        logger.log("Debugging info");
    }
}
</code></pre>
    <p><strong>Pros:</strong> Configurable, injectable, testable, and extendable. <br>
       <strong>Cons:</strong> Slightly more boilerplate.</p>

    <h2>Why Must the Instance Be Static?</h2>
    <p>The <code>instance</code> variable in a Singleton must be <strong>static</strong> so it belongs to the class, not to individual objects. This allows the class to hold and manage a single shared reference that can be accessed globally, even before any object exists. Without <code>static</code>, each object would have its own copy, which defeats the purpose of a Singleton.</p>

    <div class="footer">End of guide.</div>
  </div>
</body>
</html>
